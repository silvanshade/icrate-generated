//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CoreFoundation::*;

pub type CFMachPortRef = *mut c_void;

extern_struct!(
    #[encoding_name("?")]
    pub struct CFMachPortContext {
        pub version: CFIndex,
        pub info: *mut c_void,
        pub retain: Option<unsafe extern "C" fn(*mut c_void) -> *mut c_void>,
        pub release: Option<unsafe extern "C" fn(*mut c_void)>,
        pub copyDescription: Option<unsafe extern "C" fn(*mut c_void) -> CFStringRef>,
    }
);

pub type CFMachPortCallBack =
    Option<unsafe extern "C" fn(CFMachPortRef, *mut c_void, CFIndex, *mut c_void)>;

pub type CFMachPortInvalidationCallBack = Option<unsafe extern "C" fn(CFMachPortRef, *mut c_void)>;

extern_fn!(
    pub unsafe fn CFMachPortGetTypeID() -> CFTypeID;
);

extern_fn!(
    pub unsafe fn CFMachPortCreate(
        allocator: CFAllocatorRef,
        callout: CFMachPortCallBack,
        context: *mut CFMachPortContext,
        should_free_info: *mut Boolean,
    ) -> CFMachPortRef;
);

extern_fn!(
    pub unsafe fn CFMachPortGetContext(port: CFMachPortRef, context: *mut CFMachPortContext);
);

extern_fn!(
    pub unsafe fn CFMachPortInvalidate(port: CFMachPortRef);
);

extern_fn!(
    pub unsafe fn CFMachPortIsValid(port: CFMachPortRef) -> Boolean;
);

extern_fn!(
    pub unsafe fn CFMachPortGetInvalidationCallBack(
        port: CFMachPortRef,
    ) -> CFMachPortInvalidationCallBack;
);

extern_fn!(
    pub unsafe fn CFMachPortSetInvalidationCallBack(
        port: CFMachPortRef,
        callout: CFMachPortInvalidationCallBack,
    );
);

extern_fn!(
    pub unsafe fn CFMachPortCreateRunLoopSource(
        allocator: CFAllocatorRef,
        port: CFMachPortRef,
        order: CFIndex,
    ) -> CFRunLoopSourceRef;
);
