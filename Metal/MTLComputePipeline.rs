//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;
use crate::Metal::*;

#[objc2::interface(
    unsafe super = NSObject,
    unsafe inherits = [
    ]
)]
extern "Objective-C" {
    #[cfg(feature = "Metal_MTLComputePipelineReflection")]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub type MTLComputePipelineReflection;
}

#[cfg(feature = "Metal_MTLComputePipelineReflection")]
unsafe impl NSObjectProtocol for MTLComputePipelineReflection {}

#[objc2::interface(
    unsafe continue,
)]
extern "Objective-C" {
    #[cfg(feature = "Metal_MTLComputePipelineReflection")]
    pub type MTLComputePipelineReflection;

    #[cfg(feature = "Foundation_NSArray")]
    #[objc2::method(sel = "bindings", managed = "Other")]
    pub unsafe fn bindings(&self) -> Id<NSArray<ProtocolObject<dyn MTLBinding>>>;

    #[cfg(all(feature = "Foundation_NSArray", feature = "Metal_MTLArgument"))]
    #[deprecated]
    #[objc2::method(sel = "arguments", managed = "Other")]
    pub fn arguments(&self) -> Id<NSArray<MTLArgument>>;
}

#[objc2::interface(
    unsafe super = NSObject,
    unsafe inherits = [
    ]
)]
extern "Objective-C" {
    #[cfg(feature = "Metal_MTLComputePipelineDescriptor")]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub type MTLComputePipelineDescriptor;
}

#[cfg(feature = "Metal_MTLComputePipelineDescriptor")]
unsafe impl NSObjectProtocol for MTLComputePipelineDescriptor {}

#[objc2::interface(
    unsafe continue,
)]
extern "Objective-C" {
    #[cfg(feature = "Metal_MTLComputePipelineDescriptor")]
    pub type MTLComputePipelineDescriptor;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "label", managed = "Other")]
    pub fn label(&self) -> Option<Id<NSString>>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "setLabel:")]
    pub fn setLabel(&self, label: Option<&NSString>);

    #[objc2::method(sel = "computeFunction", managed = "Other")]
    pub fn computeFunction(&self) -> Option<Id<ProtocolObject<dyn MTLFunction>>>;

    #[objc2::method(sel = "setComputeFunction:")]
    pub fn setComputeFunction(&self, compute_function: Option<&ProtocolObject<dyn MTLFunction>>);

    #[objc2::method(sel = "threadGroupSizeIsMultipleOfThreadExecutionWidth")]
    pub fn threadGroupSizeIsMultipleOfThreadExecutionWidth(&self) -> bool;

    #[objc2::method(sel = "setThreadGroupSizeIsMultipleOfThreadExecutionWidth:")]
    pub unsafe fn setThreadGroupSizeIsMultipleOfThreadExecutionWidth(
        &self,
        thread_group_size_is_multiple_of_thread_execution_width: bool,
    );

    #[objc2::method(sel = "maxTotalThreadsPerThreadgroup")]
    pub fn maxTotalThreadsPerThreadgroup(&self) -> NSUInteger;

    #[objc2::method(sel = "setMaxTotalThreadsPerThreadgroup:")]
    pub fn setMaxTotalThreadsPerThreadgroup(&self, max_total_threads_per_threadgroup: NSUInteger);

    #[cfg(feature = "Metal_MTLStageInputOutputDescriptor")]
    #[objc2::method(sel = "stageInputDescriptor", managed = "Other")]
    pub fn stageInputDescriptor(&self) -> Option<Id<MTLStageInputOutputDescriptor>>;

    #[cfg(feature = "Metal_MTLStageInputOutputDescriptor")]
    #[objc2::method(sel = "setStageInputDescriptor:")]
    pub fn setStageInputDescriptor(
        &self,
        stage_input_descriptor: Option<&MTLStageInputOutputDescriptor>,
    );

    #[cfg(feature = "Metal_MTLPipelineBufferDescriptorArray")]
    #[objc2::method(sel = "buffers", managed = "Other")]
    pub fn buffers(&self) -> Id<MTLPipelineBufferDescriptorArray>;

    #[objc2::method(sel = "supportIndirectCommandBuffers")]
    pub fn supportIndirectCommandBuffers(&self) -> bool;

    #[objc2::method(sel = "setSupportIndirectCommandBuffers:")]
    pub fn setSupportIndirectCommandBuffers(&self, support_indirect_command_buffers: bool);

    #[cfg(feature = "Foundation_NSArray")]
    #[deprecated]
    #[objc2::method(sel = "insertLibraries", managed = "Other")]
    pub fn insertLibraries(&self) -> Option<Id<NSArray<ProtocolObject<dyn MTLDynamicLibrary>>>>;

    #[cfg(feature = "Foundation_NSArray")]
    #[deprecated]
    #[objc2::method(sel = "setInsertLibraries:")]
    pub fn setInsertLibraries(
        &self,
        insert_libraries: Option<&NSArray<ProtocolObject<dyn MTLDynamicLibrary>>>,
    );

    #[cfg(feature = "Foundation_NSArray")]
    #[objc2::method(sel = "preloadedLibraries", managed = "Other")]
    pub fn preloadedLibraries(&self) -> Id<NSArray<ProtocolObject<dyn MTLDynamicLibrary>>>;

    #[cfg(feature = "Foundation_NSArray")]
    #[objc2::method(sel = "setPreloadedLibraries:")]
    pub fn setPreloadedLibraries(
        &self,
        preloaded_libraries: &NSArray<ProtocolObject<dyn MTLDynamicLibrary>>,
    );

    #[cfg(feature = "Foundation_NSArray")]
    #[objc2::method(sel = "binaryArchives", managed = "Other")]
    pub fn binaryArchives(&self) -> Option<Id<NSArray<ProtocolObject<dyn MTLBinaryArchive>>>>;

    #[cfg(feature = "Foundation_NSArray")]
    #[objc2::method(sel = "setBinaryArchives:")]
    pub fn setBinaryArchives(
        &self,
        binary_archives: Option<&NSArray<ProtocolObject<dyn MTLBinaryArchive>>>,
    );

    #[objc2::method(sel = "reset")]
    pub fn reset(&self);

    #[cfg(feature = "Metal_MTLLinkedFunctions")]
    #[objc2::method(sel = "linkedFunctions", managed = "Other")]
    pub fn linkedFunctions(&self) -> Option<Id<MTLLinkedFunctions>>;

    #[cfg(feature = "Metal_MTLLinkedFunctions")]
    #[objc2::method(sel = "setLinkedFunctions:")]
    pub fn setLinkedFunctions(&self, linked_functions: Option<&MTLLinkedFunctions>);

    #[objc2::method(sel = "supportAddingBinaryFunctions")]
    pub fn supportAddingBinaryFunctions(&self) -> bool;

    #[objc2::method(sel = "setSupportAddingBinaryFunctions:")]
    pub fn setSupportAddingBinaryFunctions(&self, support_adding_binary_functions: bool);

    #[objc2::method(sel = "maxCallStackDepth")]
    pub fn maxCallStackDepth(&self) -> NSUInteger;

    #[objc2::method(sel = "setMaxCallStackDepth:")]
    pub fn setMaxCallStackDepth(&self, max_call_stack_depth: NSUInteger);
}

#[objc2::protocol]
pub unsafe trait MTLComputePipelineState: NSObjectProtocol {
    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "label", managed = "Other")]
    fn label(&self) -> Option<Id<NSString>>;

    #[objc2::method(sel = "device", managed = "Other")]
    fn device(&self) -> Id<ProtocolObject<dyn MTLDevice>>;

    #[objc2::method(sel = "maxTotalThreadsPerThreadgroup")]
    fn maxTotalThreadsPerThreadgroup(&self) -> NSUInteger;

    #[objc2::method(sel = "threadExecutionWidth")]
    fn threadExecutionWidth(&self) -> NSUInteger;

    #[objc2::method(sel = "staticThreadgroupMemoryLength")]
    fn staticThreadgroupMemoryLength(&self) -> NSUInteger;

    #[objc2::method(sel = "imageblockMemoryLengthForDimensions:")]
    unsafe fn imageblockMemoryLengthForDimensions(
        &self,
        imageblock_dimensions: MTLSize,
    ) -> NSUInteger;

    #[objc2::method(sel = "supportIndirectCommandBuffers")]
    fn supportIndirectCommandBuffers(&self) -> bool;

    #[objc2::method(sel = "gpuResourceID")]
    unsafe fn gpuResourceID(&self) -> MTLResourceID;

    #[objc2::method(sel = "functionHandleWithFunction:", managed = "Other")]
    fn functionHandleWithFunction(
        &self,
        function: &ProtocolObject<dyn MTLFunction>,
    ) -> Option<Id<ProtocolObject<dyn MTLFunctionHandle>>>;

    #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSError"))]
    #[objc2::method(
        sel = "newComputePipelineStateWithAdditionalBinaryFunctions:error:",
        managed = "New",
        throws
    )]
    fn newComputePipelineStateWithAdditionalBinaryFunctions_error(
        &self,
        functions: &NSArray<ProtocolObject<dyn MTLFunction>>,
    ) -> Result<Id<ProtocolObject<dyn MTLComputePipelineState>>, Id<NSError>>;

    #[cfg(feature = "Metal_MTLVisibleFunctionTableDescriptor")]
    #[objc2::method(sel = "newVisibleFunctionTableWithDescriptor:", managed = "New")]
    fn newVisibleFunctionTableWithDescriptor(
        &self,
        descriptor: &MTLVisibleFunctionTableDescriptor,
    ) -> Option<Id<ProtocolObject<dyn MTLVisibleFunctionTable>>>;

    #[cfg(feature = "Metal_MTLIntersectionFunctionTableDescriptor")]
    #[objc2::method(sel = "newIntersectionFunctionTableWithDescriptor:", managed = "New")]
    fn newIntersectionFunctionTableWithDescriptor(
        &self,
        descriptor: &MTLIntersectionFunctionTableDescriptor,
    ) -> Option<Id<ProtocolObject<dyn MTLIntersectionFunctionTable>>>;
}
