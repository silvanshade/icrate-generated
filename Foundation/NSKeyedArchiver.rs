//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;

extern_static!(NSInvalidArchiveOperationException: &'static NSExceptionName);

extern_static!(NSInvalidUnarchiveOperationException: &'static NSExceptionName);

extern_static!(NSKeyedArchiveRootObjectKey: &'static NSString);

#[objc2::interface(
    unsafe super = NSCoder,
    unsafe inherits = [
        NSObject,
    ]
)]
extern "Objective-C" {
    #[cfg(feature = "Foundation_NSKeyedArchiver")]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub type NSKeyedArchiver;
}

#[cfg(feature = "Foundation_NSKeyedArchiver")]
unsafe impl NSObjectProtocol for NSKeyedArchiver {}

#[objc2::interface(
    unsafe continue,
)]
extern "Objective-C" {
    #[cfg(feature = "Foundation_NSKeyedArchiver")]
    pub type NSKeyedArchiver;

    #[objc2::method(sel = "initRequiringSecureCoding:", managed = "Init")]
    pub unsafe fn initRequiringSecureCoding(
        this: Option<Allocated<Self>>,
        requires_secure_coding: bool,
    ) -> Id<Self>;

    #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
    #[objc2::method(
        sel = "archivedDataWithRootObject:requiringSecureCoding:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn archivedDataWithRootObject_requiringSecureCoding_error(
        object: &Object,
        requires_secure_coding: bool,
    ) -> Result<Id<NSData>, Id<NSError>>;

    #[deprecated = "Use -initRequiringSecureCoding: instead"]
    #[objc2::method(sel = "init", managed = "Init")]
    pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

    #[cfg(feature = "Foundation_NSMutableData")]
    #[deprecated = "Use -initRequiringSecureCoding: instead"]
    #[objc2::method(sel = "initForWritingWithMutableData:", managed = "Init")]
    pub unsafe fn initForWritingWithMutableData(
        this: Option<Allocated<Self>>,
        data: &NSMutableData,
    ) -> Id<Self>;

    #[cfg(feature = "Foundation_NSData")]
    #[deprecated = "Use +archivedDataWithRootObject:requiringSecureCoding:error: instead"]
    #[objc2::method(sel = "archivedDataWithRootObject:", managed = "Other")]
    pub unsafe fn archivedDataWithRootObject(root_object: &Object) -> Id<NSData>;

    #[cfg(feature = "Foundation_NSString")]
    #[deprecated = "Use +archivedDataWithRootObject:requiringSecureCoding:error: and -writeToURL:options:error: instead"]
    #[objc2::method(sel = "archiveRootObject:toFile:")]
    pub unsafe fn archiveRootObject_toFile(root_object: &Object, path: &NSString) -> bool;

    #[objc2::method(sel = "delegate", managed = "Other")]
    pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSKeyedArchiverDelegate>>>;

    #[objc2::method(sel = "setDelegate:")]
    pub unsafe fn setDelegate(
        &self,
        delegate: Option<&ProtocolObject<dyn NSKeyedArchiverDelegate>>,
    );

    #[objc2::method(sel = "outputFormat")]
    pub unsafe fn outputFormat(&self) -> NSPropertyListFormat;

    #[objc2::method(sel = "setOutputFormat:")]
    pub unsafe fn setOutputFormat(&self, output_format: NSPropertyListFormat);

    #[cfg(feature = "Foundation_NSData")]
    #[objc2::method(sel = "encodedData", managed = "Other")]
    pub unsafe fn encodedData(&self) -> Id<NSData>;

    #[objc2::method(sel = "finishEncoding")]
    pub unsafe fn finishEncoding(&self);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "setClassName:forClass:")]
    pub unsafe fn setClassName_forClass_class(coded_name: Option<&NSString>, cls: &Class);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "setClassName:forClass:")]
    pub unsafe fn setClassName_forClass(&self, coded_name: Option<&NSString>, cls: &Class);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "classNameForClass:", managed = "Other")]
    pub unsafe fn classNameForClass_class(cls: &Class) -> Option<Id<NSString>>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "classNameForClass:", managed = "Other")]
    pub unsafe fn classNameForClass(&self, cls: &Class) -> Option<Id<NSString>>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeObject:forKey:")]
    pub unsafe fn encodeObject_forKey(&self, object: Option<&Object>, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeConditionalObject:forKey:")]
    pub unsafe fn encodeConditionalObject_forKey(&self, object: Option<&Object>, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeBool:forKey:")]
    pub unsafe fn encodeBool_forKey(&self, value: bool, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeInt:forKey:")]
    pub unsafe fn encodeInt_forKey(&self, value: c_int, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeInt32:forKey:")]
    pub unsafe fn encodeInt32_forKey(&self, value: i32, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeInt64:forKey:")]
    pub unsafe fn encodeInt64_forKey(&self, value: i64, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeFloat:forKey:")]
    pub unsafe fn encodeFloat_forKey(&self, value: c_float, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeDouble:forKey:")]
    pub unsafe fn encodeDouble_forKey(&self, value: c_double, key: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "encodeBytes:length:forKey:")]
    pub unsafe fn encodeBytes_length_forKey(
        &self,
        bytes: *mut u8,
        length: NSUInteger,
        key: &NSString,
    );

    #[objc2::method(sel = "requiresSecureCoding")]
    pub unsafe fn requiresSecureCoding(&self) -> bool;

    #[objc2::method(sel = "setRequiresSecureCoding:")]
    pub unsafe fn setRequiresSecureCoding(&self, requires_secure_coding: bool);
}

#[objc2::interface(
    unsafe super = NSCoder,
    unsafe inherits = [
        NSObject,
    ]
)]
extern "Objective-C" {
    #[cfg(feature = "Foundation_NSKeyedUnarchiver")]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub type NSKeyedUnarchiver;
}

#[cfg(feature = "Foundation_NSKeyedUnarchiver")]
unsafe impl NSObjectProtocol for NSKeyedUnarchiver {}

#[objc2::interface(
    unsafe continue,
)]
extern "Objective-C" {
    #[cfg(feature = "Foundation_NSKeyedUnarchiver")]
    pub type NSKeyedUnarchiver;

    #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
    #[objc2::method(sel = "initForReadingFromData:error:", managed = "Init", throws)]
    pub unsafe fn initForReadingFromData_error(
        this: Option<Allocated<Self>>,
        data: &NSData,
    ) -> Result<Id<Self>, Id<NSError>>;

    #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
    #[objc2::method(
        sel = "unarchivedObjectOfClass:fromData:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn unarchivedObjectOfClass_fromData_error(
        cls: &Class,
        data: &NSData,
    ) -> Result<Id<Object>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSArray",
        feature = "Foundation_NSData",
        feature = "Foundation_NSError"
    ))]
    #[objc2::method(
        sel = "unarchivedArrayOfObjectsOfClass:fromData:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn unarchivedArrayOfObjectsOfClass_fromData_error(
        cls: &Class,
        data: &NSData,
    ) -> Result<Id<NSArray>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSData",
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError"
    ))]
    #[objc2::method(
        sel = "unarchivedDictionaryWithKeysOfClass:objectsOfClass:fromData:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn unarchivedDictionaryWithKeysOfClass_objectsOfClass_fromData_error(
        key_cls: &Class,
        value_cls: &Class,
        data: &NSData,
    ) -> Result<Id<NSDictionary>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSData",
        feature = "Foundation_NSError",
        feature = "Foundation_NSSet"
    ))]
    #[objc2::method(
        sel = "unarchivedObjectOfClasses:fromData:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn unarchivedObjectOfClasses_fromData_error(
        classes: &NSSet<TodoClass>,
        data: &NSData,
    ) -> Result<Id<Object>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSArray",
        feature = "Foundation_NSData",
        feature = "Foundation_NSError",
        feature = "Foundation_NSSet"
    ))]
    #[objc2::method(
        sel = "unarchivedArrayOfObjectsOfClasses:fromData:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn unarchivedArrayOfObjectsOfClasses_fromData_error(
        classes: &NSSet<TodoClass>,
        data: &NSData,
    ) -> Result<Id<NSArray>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSData",
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSSet"
    ))]
    #[objc2::method(
        sel = "unarchivedDictionaryWithKeysOfClasses:objectsOfClasses:fromData:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn unarchivedDictionaryWithKeysOfClasses_objectsOfClasses_fromData_error(
        key_classes: &NSSet<TodoClass>,
        value_classes: &NSSet<TodoClass>,
        data: &NSData,
    ) -> Result<Id<NSDictionary>, Id<NSError>>;

    #[deprecated = "Use -initForReadingFromData:error: instead"]
    #[objc2::method(sel = "init", managed = "Init")]
    pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self>;

    #[cfg(feature = "Foundation_NSData")]
    #[deprecated = "Use -initForReadingFromData:error: instead"]
    #[objc2::method(sel = "initForReadingWithData:", managed = "Init")]
    pub unsafe fn initForReadingWithData(this: Option<Allocated<Self>>, data: &NSData) -> Id<Self>;

    #[cfg(feature = "Foundation_NSData")]
    #[deprecated = "Use +unarchivedObjectOfClass:fromData:error: instead"]
    #[objc2::method(sel = "unarchiveObjectWithData:", managed = "Other")]
    pub unsafe fn unarchiveObjectWithData(data: &NSData) -> Option<Id<Object>>;

    #[cfg(all(feature = "Foundation_NSData", feature = "Foundation_NSError"))]
    #[deprecated = "Use +unarchivedObjectOfClass:fromData:error: instead"]
    #[objc2::method(
        sel = "unarchiveTopLevelObjectWithData:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn unarchiveTopLevelObjectWithData_error(
        data: &NSData,
    ) -> Result<Id<Object>, Id<NSError>>;

    #[cfg(feature = "Foundation_NSString")]
    #[deprecated = "Use +unarchivedObjectOfClass:fromData:error: instead"]
    #[objc2::method(sel = "unarchiveObjectWithFile:", managed = "Other")]
    pub unsafe fn unarchiveObjectWithFile(path: &NSString) -> Option<Id<Object>>;

    #[objc2::method(sel = "delegate", managed = "Other")]
    pub unsafe fn delegate(&self) -> Option<Id<ProtocolObject<dyn NSKeyedUnarchiverDelegate>>>;

    #[objc2::method(sel = "setDelegate:")]
    pub unsafe fn setDelegate(
        &self,
        delegate: Option<&ProtocolObject<dyn NSKeyedUnarchiverDelegate>>,
    );

    #[objc2::method(sel = "finishDecoding")]
    pub unsafe fn finishDecoding(&self);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "setClass:forClassName:")]
    pub unsafe fn setClass_forClassName_class(cls: Option<&Class>, coded_name: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "setClass:forClassName:")]
    pub unsafe fn setClass_forClassName(&self, cls: Option<&Class>, coded_name: &NSString);

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "classForClassName:")]
    pub unsafe fn classForClassName_class(coded_name: &NSString) -> Option<&'static Class>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "classForClassName:")]
    pub unsafe fn classForClassName(&self, coded_name: &NSString) -> Option<&'static Class>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "containsValueForKey:")]
    pub unsafe fn containsValueForKey(&self, key: &NSString) -> bool;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeObjectForKey:", managed = "Other")]
    pub unsafe fn decodeObjectForKey(&self, key: &NSString) -> Option<Id<Object>>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeBoolForKey:")]
    pub unsafe fn decodeBoolForKey(&self, key: &NSString) -> bool;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeIntForKey:")]
    pub unsafe fn decodeIntForKey(&self, key: &NSString) -> c_int;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeInt32ForKey:")]
    pub unsafe fn decodeInt32ForKey(&self, key: &NSString) -> i32;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeInt64ForKey:")]
    pub unsafe fn decodeInt64ForKey(&self, key: &NSString) -> i64;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeFloatForKey:")]
    pub unsafe fn decodeFloatForKey(&self, key: &NSString) -> c_float;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeDoubleForKey:")]
    pub unsafe fn decodeDoubleForKey(&self, key: &NSString) -> c_double;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "decodeBytesForKey:returnedLength:")]
    pub unsafe fn decodeBytesForKey_returnedLength(
        &self,
        key: &NSString,
        lengthp: *mut NSUInteger,
    ) -> *mut u8;

    #[objc2::method(sel = "requiresSecureCoding")]
    pub unsafe fn requiresSecureCoding(&self) -> bool;

    #[objc2::method(sel = "setRequiresSecureCoding:")]
    pub unsafe fn setRequiresSecureCoding(&self, requires_secure_coding: bool);

    #[objc2::method(sel = "decodingFailurePolicy")]
    pub unsafe fn decodingFailurePolicy(&self) -> NSDecodingFailurePolicy;

    #[objc2::method(sel = "setDecodingFailurePolicy:")]
    pub unsafe fn setDecodingFailurePolicy(&self, decoding_failure_policy: NSDecodingFailurePolicy);
}

#[objc2::protocol]
pub unsafe trait NSKeyedArchiverDelegate: NSObjectProtocol {
    #[cfg(feature = "Foundation_NSKeyedArchiver")]
    #[objc2::method(optional, sel = "archiver:willEncodeObject:", managed = "Other")]
    unsafe fn archiver_willEncodeObject(
        &self,
        archiver: &NSKeyedArchiver,
        object: &Object,
    ) -> Option<Id<Object>>;

    #[cfg(feature = "Foundation_NSKeyedArchiver")]
    #[objc2::method(optional, sel = "archiver:didEncodeObject:")]
    unsafe fn archiver_didEncodeObject(&self, archiver: &NSKeyedArchiver, object: Option<&Object>);

    #[cfg(feature = "Foundation_NSKeyedArchiver")]
    #[objc2::method(optional, sel = "archiver:willReplaceObject:withObject:")]
    unsafe fn archiver_willReplaceObject_withObject(
        &self,
        archiver: &NSKeyedArchiver,
        object: Option<&Object>,
        new_object: Option<&Object>,
    );

    #[cfg(feature = "Foundation_NSKeyedArchiver")]
    #[objc2::method(optional, sel = "archiverWillFinish:")]
    unsafe fn archiverWillFinish(&self, archiver: &NSKeyedArchiver);

    #[cfg(feature = "Foundation_NSKeyedArchiver")]
    #[objc2::method(optional, sel = "archiverDidFinish:")]
    unsafe fn archiverDidFinish(&self, archiver: &NSKeyedArchiver);
}

#[objc2::protocol]
pub unsafe trait NSKeyedUnarchiverDelegate: NSObjectProtocol {
    #[cfg(all(
        feature = "Foundation_NSArray",
        feature = "Foundation_NSKeyedUnarchiver",
        feature = "Foundation_NSString"
    ))]
    #[objc2::method(
        optional,
        sel = "unarchiver:cannotDecodeObjectOfClassName:originalClasses:"
    )]
    unsafe fn unarchiver_cannotDecodeObjectOfClassName_originalClasses(
        &self,
        unarchiver: &NSKeyedUnarchiver,
        name: &NSString,
        class_names: &NSArray<NSString>,
    ) -> Option<&'static Class>;

    #[cfg(feature = "Foundation_NSKeyedUnarchiver")]
    #[objc2::method(optional, sel = "unarchiver:willReplaceObject:withObject:")]
    unsafe fn unarchiver_willReplaceObject_withObject(
        &self,
        unarchiver: &NSKeyedUnarchiver,
        object: &Object,
        new_object: &Object,
    );

    #[cfg(feature = "Foundation_NSKeyedUnarchiver")]
    #[objc2::method(optional, sel = "unarchiverWillFinish:")]
    unsafe fn unarchiverWillFinish(&self, unarchiver: &NSKeyedUnarchiver);

    #[cfg(feature = "Foundation_NSKeyedUnarchiver")]
    #[objc2::method(optional, sel = "unarchiverDidFinish:")]
    unsafe fn unarchiverDidFinish(&self, unarchiver: &NSKeyedUnarchiver);
}
