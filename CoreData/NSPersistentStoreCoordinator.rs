//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::CoreData::*;
use crate::Foundation::*;

extern_static!(NSSQLiteStoreType: &'static NSString);

extern_static!(NSXMLStoreType: &'static NSString);

extern_static!(NSBinaryStoreType: &'static NSString);

extern_static!(NSInMemoryStoreType: &'static NSString);

extern_static!(NSStoreTypeKey: &'static NSString);

extern_static!(NSStoreUUIDKey: &'static NSString);

extern_static!(NSPersistentStoreCoordinatorStoresWillChangeNotification: &'static NSString);

extern_static!(NSPersistentStoreCoordinatorStoresDidChangeNotification: &'static NSString);

extern_static!(NSPersistentStoreCoordinatorWillRemoveStoreNotification: &'static NSString);

extern_static!(NSAddedPersistentStoresKey: &'static NSString);

extern_static!(NSRemovedPersistentStoresKey: &'static NSString);

extern_static!(NSUUIDChangedPersistentStoresKey: &'static NSString);

extern_static!(NSReadOnlyPersistentStoreOption: &'static NSString);

extern_static!(NSValidateXMLStoreOption: &'static NSString);

extern_static!(NSPersistentStoreTimeoutOption: &'static NSString);

extern_static!(NSSQLitePragmasOption: &'static NSString);

extern_static!(NSSQLiteAnalyzeOption: &'static NSString);

extern_static!(NSSQLiteManualVacuumOption: &'static NSString);

extern_static!(NSIgnorePersistentStoreVersioningOption: &'static NSString);

extern_static!(NSMigratePersistentStoresAutomaticallyOption: &'static NSString);

extern_static!(NSInferMappingModelAutomaticallyOption: &'static NSString);

extern_static!(NSStoreModelVersionHashesKey: &'static NSString);

extern_static!(NSStoreModelVersionIdentifiersKey: &'static NSString);

extern_static!(NSPersistentStoreOSCompatibility: &'static NSString);

extern_static!(NSPersistentStoreConnectionPoolMaxSizeKey: &'static NSString);

extern_static!(NSCoreDataCoreSpotlightExporter: &'static NSString);

extern_static!(NSXMLExternalRecordType: &'static NSString);

extern_static!(NSBinaryExternalRecordType: &'static NSString);

extern_static!(NSExternalRecordsFileFormatOption: &'static NSString);

extern_static!(NSExternalRecordsDirectoryOption: &'static NSString);

extern_static!(NSExternalRecordExtensionOption: &'static NSString);

extern_static!(NSEntityNameInPathKey: &'static NSString);

extern_static!(NSStoreUUIDInPathKey: &'static NSString);

extern_static!(NSStorePathKey: &'static NSString);

extern_static!(NSModelPathKey: &'static NSString);

extern_static!(NSObjectURIKey: &'static NSString);

extern_static!(NSPersistentStoreForceDestroyOption: &'static NSString);

extern_static!(NSPersistentStoreFileProtectionKey: &'static NSString);

extern_static!(NSPersistentHistoryTrackingKey: &'static NSString);

extern_static!(NSBinaryStoreSecureDecodingClasses: &'static NSString);

extern_static!(NSBinaryStoreInsecureDecodingCompatibilityOption: &'static NSString);

extern_static!(NSPersistentStoreRemoteChangeNotificationPostOptionKey: &'static NSString);

extern_static!(NSPersistentStoreRemoteChangeNotification: &'static NSString);

extern_static!(NSPersistentStoreURLKey: &'static NSString);

extern_static!(NSPersistentHistoryTokenKey: &'static NSString);

#[objc2::interface(
    unsafe super = NSObject,
    unsafe inherits = [
    ]
)]
extern "Objective-C" {
    #[cfg(feature = "CoreData_NSPersistentStoreCoordinator")]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub type NSPersistentStoreCoordinator;
}

#[cfg(feature = "CoreData_NSPersistentStoreCoordinator")]
unsafe impl NSLocking for NSPersistentStoreCoordinator {}

#[cfg(feature = "CoreData_NSPersistentStoreCoordinator")]
unsafe impl NSObjectProtocol for NSPersistentStoreCoordinator {}

#[objc2::interface(
    unsafe continue,
)]
extern "Objective-C" {
    #[cfg(feature = "CoreData_NSPersistentStoreCoordinator")]
    pub type NSPersistentStoreCoordinator;

    #[cfg(feature = "CoreData_NSManagedObjectModel")]
    #[objc2::method(sel = "initWithManagedObjectModel:", managed = "Init")]
    pub unsafe fn initWithManagedObjectModel(
        this: Option<Allocated<Self>>,
        model: &NSManagedObjectModel,
    ) -> Id<Self>;

    #[cfg(feature = "CoreData_NSManagedObjectModel")]
    #[objc2::method(sel = "managedObjectModel", managed = "Other")]
    pub unsafe fn managedObjectModel(&self) -> Id<NSManagedObjectModel>;

    #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSArray"))]
    #[objc2::method(sel = "persistentStores", managed = "Other")]
    pub unsafe fn persistentStores(&self) -> Id<NSArray<NSPersistentStore>>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "name", managed = "Other")]
    pub unsafe fn name(&self) -> Option<Id<NSString>>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "setName:")]
    pub unsafe fn setName(&self, name: Option<&NSString>);

    #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSURL"))]
    #[objc2::method(sel = "persistentStoreForURL:", managed = "Other")]
    pub unsafe fn persistentStoreForURL(&self, url: &NSURL) -> Option<Id<NSPersistentStore>>;

    #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSURL"))]
    #[objc2::method(sel = "URLForPersistentStore:", managed = "Other")]
    pub unsafe fn URLForPersistentStore(&self, store: &NSPersistentStore) -> Id<NSURL>;

    #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSURL"))]
    #[objc2::method(sel = "setURL:forPersistentStore:")]
    pub unsafe fn setURL_forPersistentStore(&self, url: &NSURL, store: &NSPersistentStore) -> bool;

    #[cfg(all(
        feature = "CoreData_NSPersistentStore",
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[objc2::method(
        sel = "addPersistentStoreWithType:configuration:URL:options:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn addPersistentStoreWithType_configuration_URL_options_error(
        &self,
        store_type: &NSString,
        configuration: Option<&NSString>,
        store_url: Option<&NSURL>,
        options: Option<&NSDictionary>,
    ) -> Result<Id<NSPersistentStore>, Id<NSError>>;

    #[cfg(all(
        feature = "CoreData_NSPersistentStoreDescription",
        feature = "Foundation_NSError"
    ))]
    #[objc2::method(sel = "addPersistentStoreWithDescription:completionHandler:")]
    pub unsafe fn addPersistentStoreWithDescription_completionHandler(
        &self,
        store_description: &NSPersistentStoreDescription,
        block: &Block<(NonNull<NSPersistentStoreDescription>, *mut NSError), ()>,
    );

    #[cfg(all(feature = "CoreData_NSPersistentStore", feature = "Foundation_NSError"))]
    #[objc2::method(sel = "removePersistentStore:error:", throws)]
    pub unsafe fn removePersistentStore_error(
        &self,
        store: &NSPersistentStore,
    ) -> Result<(), Id<NSError>>;

    #[cfg(all(
        feature = "CoreData_NSPersistentStore",
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSString"
    ))]
    #[objc2::method(sel = "setMetadata:forPersistentStore:")]
    pub unsafe fn setMetadata_forPersistentStore(
        &self,
        metadata: Option<&NSDictionary<NSString, Object>>,
        store: &NSPersistentStore,
    );

    #[cfg(all(
        feature = "CoreData_NSPersistentStore",
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSString"
    ))]
    #[objc2::method(sel = "metadataForPersistentStore:", managed = "Other")]
    pub unsafe fn metadataForPersistentStore(
        &self,
        store: &NSPersistentStore,
    ) -> Id<NSDictionary<NSString, Object>>;

    #[cfg(all(feature = "CoreData_NSManagedObjectID", feature = "Foundation_NSURL"))]
    #[objc2::method(sel = "managedObjectIDForURIRepresentation:", managed = "Other")]
    pub unsafe fn managedObjectIDForURIRepresentation(
        &self,
        url: &NSURL,
    ) -> Option<Id<NSManagedObjectID>>;

    #[cfg(all(
        feature = "CoreData_NSManagedObjectContext",
        feature = "CoreData_NSPersistentStoreRequest",
        feature = "Foundation_NSError"
    ))]
    #[objc2::method(sel = "executeRequest:withContext:error:", managed = "Other", throws)]
    pub unsafe fn executeRequest_withContext_error(
        &self,
        request: &NSPersistentStoreRequest,
        context: &NSManagedObjectContext,
    ) -> Result<Id<Object>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSString",
        feature = "Foundation_NSValue"
    ))]
    #[objc2::method(sel = "registeredStoreTypes", managed = "Other")]
    pub unsafe fn registeredStoreTypes() -> Id<NSDictionary<NSString, NSValue>>;

    #[cfg(feature = "Foundation_NSString")]
    #[objc2::method(sel = "registerStoreClass:forStoreType:")]
    pub unsafe fn registerStoreClass_forStoreType(
        store_class: Option<&Class>,
        store_type: &NSString,
    );

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[objc2::method(
        sel = "metadataForPersistentStoreOfType:URL:options:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn metadataForPersistentStoreOfType_URL_options_error(
        store_type: &NSString,
        url: &NSURL,
        options: Option<&NSDictionary>,
    ) -> Result<Id<NSDictionary<NSString, Object>>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[objc2::method(
        sel = "setMetadata:forPersistentStoreOfType:URL:options:error:",
        throws
    )]
    pub unsafe fn setMetadata_forPersistentStoreOfType_URL_options_error(
        metadata: Option<&NSDictionary<NSString, Object>>,
        store_type: &NSString,
        url: &NSURL,
        options: Option<&NSDictionary>,
    ) -> Result<(), Id<NSError>>;

    #[cfg(all(feature = "Foundation_NSDictionary", feature = "Foundation_NSURL"))]
    #[deprecated = "Spotlight integration is deprecated. Use CoreSpotlight integration instead."]
    #[objc2::method(sel = "elementsDerivedFromExternalRecordURL:", managed = "Other")]
    pub unsafe fn elementsDerivedFromExternalRecordURL(file_url: &NSURL) -> Id<NSDictionary>;

    #[cfg(all(
        feature = "CoreData_NSPersistentStore",
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[deprecated = "Spotlight integration is deprecated. Use CoreSpotlight integration instead."]
    #[objc2::method(
        sel = "importStoreWithIdentifier:fromExternalRecordsDirectory:toURL:options:withType:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn importStoreWithIdentifier_fromExternalRecordsDirectory_toURL_options_withType_error(
        &self,
        store_identifier: Option<&NSString>,
        external_records_url: &NSURL,
        destination_url: &NSURL,
        options: Option<&NSDictionary>,
        store_type: &NSString,
    ) -> Result<Id<NSPersistentStore>, Id<NSError>>;

    #[cfg(all(
        feature = "CoreData_NSPersistentStore",
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[objc2::method(
        sel = "migratePersistentStore:toURL:options:withType:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn migratePersistentStore_toURL_options_withType_error(
        &self,
        store: &NSPersistentStore,
        url: &NSURL,
        options: Option<&NSDictionary>,
        store_type: &NSString,
    ) -> Result<Id<NSPersistentStore>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[objc2::method(sel = "destroyPersistentStoreAtURL:withType:options:error:", throws)]
    pub unsafe fn destroyPersistentStoreAtURL_withType_options_error(
        &self,
        url: &NSURL,
        store_type: &NSString,
        options: Option<&NSDictionary>,
    ) -> Result<(), Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[objc2::method(
        sel = "replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:",
        throws
    )]
    pub unsafe fn replacePersistentStoreAtURL_destinationOptions_withPersistentStoreFromURL_sourceOptions_storeType_error(
        &self,
        destination_url: &NSURL,
        destination_options: Option<&NSDictionary>,
        source_url: &NSURL,
        source_options: Option<&NSDictionary>,
        store_type: &NSString,
    ) -> Result<(), Id<NSError>>;

    #[objc2::method(sel = "performBlock:")]
    pub unsafe fn performBlock(&self, block: &Block<(), ()>);

    #[objc2::method(sel = "performBlockAndWait:")]
    pub unsafe fn performBlockAndWait(&self, block: &Block<(), ()>);

    #[cfg(all(
        feature = "CoreData_NSPersistentHistoryToken",
        feature = "Foundation_NSArray"
    ))]
    #[objc2::method(sel = "currentPersistentHistoryTokenFromStores:", managed = "Other")]
    pub unsafe fn currentPersistentHistoryTokenFromStores(
        &self,
        stores: Option<&NSArray>,
    ) -> Option<Id<NSPersistentHistoryToken>>;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSURL"
    ))]
    #[deprecated = "Use -metadataForPersistentStoreOfType:URL:options:error: and pass in an options dictionary matching addPersistentStoreWithType"]
    #[objc2::method(
        sel = "metadataForPersistentStoreWithURL:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn metadataForPersistentStoreWithURL_error(
        url: &NSURL,
    ) -> Result<Id<NSDictionary>, Id<NSError>>;

    #[deprecated = "Use -performBlockAndWait: instead"]
    #[objc2::method(sel = "lock")]
    pub unsafe fn lock(&self);

    #[deprecated = "Use -performBlockAndWait: instead"]
    #[objc2::method(sel = "unlock")]
    pub unsafe fn unlock(&self);

    #[deprecated = "Use -performBlock: instead"]
    #[objc2::method(sel = "tryLock")]
    pub unsafe fn tryLock(&self) -> bool;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[deprecated = "Use -metadataForPersistentStoreOfType:URL:options:error: and pass in an options dictionary matching addPersistentStoreWithType"]
    #[objc2::method(
        sel = "metadataForPersistentStoreOfType:URL:error:",
        managed = "Other",
        throws
    )]
    pub unsafe fn metadataForPersistentStoreOfType_URL_error(
        store_type: Option<&NSString>,
        url: &NSURL,
    ) -> Result<Id<NSDictionary<NSString, Object>>, Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSString",
        feature = "Foundation_NSURL"
    ))]
    #[deprecated = "Use  -setMetadata:forPersistentStoreOfType:URL:options:error: and pass in an options dictionary matching addPersistentStoreWithType"]
    #[objc2::method(sel = "setMetadata:forPersistentStoreOfType:URL:error:", throws)]
    pub unsafe fn setMetadata_forPersistentStoreOfType_URL_error(
        metadata: Option<&NSDictionary<NSString, Object>>,
        store_type: Option<&NSString>,
        url: &NSURL,
    ) -> Result<(), Id<NSError>>;

    #[cfg(all(
        feature = "Foundation_NSDictionary",
        feature = "Foundation_NSError",
        feature = "Foundation_NSURL"
    ))]
    #[deprecated = "Please see the release notes and Core Data documentation."]
    #[objc2::method(
        sel = "removeUbiquitousContentAndPersistentStoreAtURL:options:error:",
        throws
    )]
    pub unsafe fn removeUbiquitousContentAndPersistentStoreAtURL_options_error(
        store_url: &NSURL,
        options: Option<&NSDictionary>,
    ) -> Result<(), Id<NSError>>;
}

#[ns_enum]
#[underlying(NSUInteger)]
#[deprecated = "Please see the release notes and Core Data documentation."]
pub enum NSPersistentStoreUbiquitousTransitionType {
    #[deprecated = "Please see the release notes and Core Data documentation."]
    NSPersistentStoreUbiquitousTransitionTypeAccountAdded = 1,
    #[deprecated = "Please see the release notes and Core Data documentation."]
    NSPersistentStoreUbiquitousTransitionTypeAccountRemoved = 2,
    #[deprecated = "Please see the release notes and Core Data documentation."]
    NSPersistentStoreUbiquitousTransitionTypeContentRemoved = 3,
    #[deprecated = "Please see the release notes and Core Data documentation."]
    NSPersistentStoreUbiquitousTransitionTypeInitialImportCompleted = 4,
}

extern_static!(NSPersistentStoreUbiquitousContentNameKey: &'static NSString);

extern_static!(NSPersistentStoreUbiquitousContentURLKey: &'static NSString);

extern_static!(NSPersistentStoreDidImportUbiquitousContentChangesNotification: &'static NSString);

extern_static!(NSPersistentStoreUbiquitousTransitionTypeKey: &'static NSString);

extern_static!(NSPersistentStoreUbiquitousPeerTokenOption: &'static NSString);

extern_static!(NSPersistentStoreRemoveUbiquitousMetadataOption: &'static NSString);

extern_static!(NSPersistentStoreUbiquitousContainerIdentifierKey: &'static NSString);

extern_static!(NSPersistentStoreRebuildFromUbiquitousContentOption: &'static NSString);
